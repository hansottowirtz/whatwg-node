diff --git a/node_modules/@pulumi/pulumi/runtime/closure/createClosure.js b/node_modules/@pulumi/pulumi/runtime/closure/createClosure.js
index d065424..26b7d88 100644
--- a/node_modules/@pulumi/pulumi/runtime/closure/createClosure.js
+++ b/node_modules/@pulumi/pulumi/runtime/closure/createClosure.js
@@ -761,9 +761,12 @@ function getOrCreateEntryAsync(obj, capturedObjectProperties, context, serialize
                 // things up properly.
                 //
                 // We don't need to capture the prototype if the user is not capturing 'this' either.
-                if (!object.proto) {
+                if (!object.proto && !obj.sym) {
                     const proto = Object.getPrototypeOf(obj);
-                    if (proto !== Object.prototype) {
+                    if (proto === Symbol.prototype) { // Also treat symbol as a special case
+                        object.sym = obj; // added a new info object to maintain the symbol
+                    }
+                    else if (proto !== Object.prototype) {
                         object.proto = yield getOrCreateEntryAsync(proto, undefined, context, serialize, logInfo);
                     }
                 }
diff --git a/node_modules/@pulumi/pulumi/runtime/closure/serializeClosure.js b/node_modules/@pulumi/pulumi/runtime/closure/serializeClosure.js
index 79e2b95..3286ce1 100644
--- a/node_modules/@pulumi/pulumi/runtime/closure/serializeClosure.js
+++ b/node_modules/@pulumi/pulumi/runtime/closure/serializeClosure.js
@@ -265,11 +265,20 @@ function serializeJavaScriptText(outerClosure, exportName, isFactoryFunction) {
             // Then we can walk our children, creating a single assignment per child.
             // This way, if the child ends up referencing us, we'll have already emitted
             // the **initialized** variable for them to reference.
-            if (obj.proto) {
+            if(obj.sym) {
+                const key = Symbol.keyFor(obj.sym);
+                environmentText += key ?
+                    // Symbol.keyFor returns a key when the symbol was originally registered globally
+                    // In this case, lets register or get the global symbol.
+                    `var ${envVar} = Symbol.for("${key}");\n` :
+                    // Local symbols will return undefined for keyFor, lets make another local symbol.
+                    // @ts-ignore
+                    `var ${envVar} = Symbol("${obj.sym.description}");\n`;
+            }
+            else if (obj.proto) {
                 const protoVar = envEntryToString(obj.proto, `${varName}_proto`);
                 environmentText += `var ${envVar} = Object.create(${protoVar});\n`;
-            }
-            else {
+            } else {
                 environmentText += `var ${envVar} = {};\n`;
             }
             emitComplexObjectProperties(envVar, varName, obj);
